(include "compatibility.scm")
(include "stdlib.scm")
(include "environment.scm")
(include "helper.scm")
(include "llvm.scm")
(include "syntax/if.scm")
(include "syntax/begin.scm")
(include "syntax/let.scm")
(include "syntax/string.scm")
(include "preprocessing/syntax-desugar.scm")
(include "preprocessing/alpha-convert.scm")
(include "preprocessing/a-normalize.scm")
(include "preprocessing/closure-convert.scm")

(def tag_mask #b111)
(def fixnum_tag #b000)

(def char_tag #b010)
(def constant_tag #b111)
(def true  #b111111)
(def false #b011111)
(def null  #b000111)

(defn immediate? (x)
  (or (fixnum? x) (boolean? x) (char? x) (null? x)))

(defn atomic? (x)
  (or (immediate? x) (symbol? x) (string? x))) 

(defn immediate-rep (x)
  (cond
    ((fixnum? x) 
     (fxshl x 3))
    ((char? x)
     (+ (fxshl (char->integer x) 3)
        char_tag))
    ((boolean? x)
     (if x true false))
    ((null? x) null)
    (else (error "Invalid expression: " x))))

(defn variable? (expr) (symbol? expr))

(defn emit-immediate (var expr)
  (let ((tmp (generate-var)))
    (emit-alloca tmp)
    (emit-store (immediate-rep expr) tmp)
    (emit-load var tmp)))

(defn defn? (expr) (tagged-list? expr 'defprim))
(def defn-name frst)
(def defn-args frrst)
(defn defn-body (expr)
  (if (= 1 (length (rrrst expr)))
      (frrrst expr)
      (cons 'begin (rrrst expr))))

(defn make-defn (name args body)
  (cons 'defprim
        (cons name
              (cons args body))))

; (defn emit-toplevel-expr (expr)
;   (cond
;     ((defn? expr)
;      (let* ((name (defn-name expr))
;             (args (defn-args expr))
;             (args-with-vars (map (fn (arg) (cons arg (generate-var))) args))
;             (args-string
;               (string-join2 (map (fn (a) (string-append "i64 " (rst a))) args-with-vars) ", ")))
;        (print (string-append* (list "define i64 @" (escape name) "(" args-string ") {")))
;        (emit-expr "%res" args-with-vars (defn-body expr))
;        (emit-ret "%res")
;        (print "}")))
;      (else (error "Invalid toplevel expression: " expr))))

(defn emit-lambda (expr)
  (let* ((name (fst expr))
         (lmbda (frst expr))
         (args (lambda-args lmbda))
         (arity (length args))
         (body (lambda-body lmbda))
         (prep-body (pipe body normalize-term))
         (args-with-vars (map (fn (arg) (cons arg (generate-var))) args))
         (args-string
           (string-join2 (map (fn (a) (string-append "i64 " (rst a))) args-with-vars) ", ")))
    (print (string-append* (list "define i64 @lambda_" (symbol->string name) "(" args-string ") {")))
    (emit-expr "%res" args-with-vars prep-body)
    (emit-ret "%res")
    (print "}")))

(defn emit-global-var (var)
  (print (string-append* (list "@var_" (escape var) " = weak global i64 0"))))

(defn emit-expr (var env expr)
  (cond
    ((immediate? expr) (emit-immediate var expr))
    ((string? expr) (emit-string var expr))
    ((tagged-list? expr 'quote) (emit-symbol var (frst expr)))
    ((if? expr) (emit-if var env expr))
    ((begin? expr) (emit-begin var env expr))
    ((let? expr) (emit-let var env expr))
    ((tagged-list? expr 'make-closure)
     (let ((tmp1 (generate-var))
           (tmp2 (generate-var))
           (name (frst expr))
           (arity (frrst expr))
           (env_ (frrrst expr)))
       (print (string-append* (list "  " tmp1 " = ptrtoint i64 (" (arg-str (add1 arity)) ")* @lambda_" (symbol->string name) " to i64")))
       (emit-expr tmp2 env env_)
       (emit-call3 var "@internal_make-closure" tmp1 (fixnum->string (immediate-rep arity)) tmp2)
       ))
    ((tagged-list? expr 'def)
     (let ((tmp (generate-var))
           (name (frst expr))
           (value (frrst expr)))
       (emit-expr tmp env value)
       (emit-store tmp (string-append "@var_" (escape name)))))
    ((list? expr)
     (let* ((name (fst expr))
            (args (rst expr))
            (vars (map (fn (arg)
                         (string-append
                           "i64 "
                           (let ((res (assoc arg env)))
                             (if res (rst res) (show (immediate-rep arg))))))
                       args)))
       (if (primitive? name)
         (print (string-append* (list "  " var " = call i64 @" (escape name) "(" (string-join2 vars ", ") ")" )))
         (begin
           (let ((tmp1 (generate-var))
                 (tmp2 (generate-var))
                 (tmp3 (generate-var))
                 (tmp4 (generate-var))
                 (arity (length args)))
             (emit-variable-ref tmp1 env name)
             (emit-call1 tmp2 "@internal_closure-function" tmp1)
             (emit-call1 tmp4 "@prim_closure-env" tmp1)
             (print (string-append* (list "  " tmp3 " = inttoptr i64 " tmp2 " to i64 (" (arg-str (add1 arity)) ")*")))  
             (print (string-append* (list "  " var  " = call i64 " tmp3 "(i64 " tmp4 ", " (string-join2 vars ", ") ")"))))))))
    ((variable? expr) (emit-variable-ref var env expr))
    (else
      (error "Unknown expression: " expr))))

(defn emit-variable-ref (var env expr)
  (let ((var_ (lookup-or expr #f env)))
    (if var_
      (let ((tmp (generate-var)))
        (emit-alloca tmp)
        (emit-store var_ tmp)
        (emit-load var tmp))
      (let ((tmp (generate-var)))
        (emit-load var (string-append "@var_" (escape expr)))))))

(defn emit-symbol (var expr)
  (let ((tmp (generate-var)))
    (emit-string tmp (symbol->string expr))
    (emit-call1 var "@prim_string-_greater_symbol" tmp)))

(defn emit-program (exprs)
  (let ((preprocessed (map (fn (expr) (pipe expr syntax-desugar alpha-convert-expr closure-convert normalize-term))
                           (append stdlib exprs))))
    (for-each emit-global-var global_vars)
    (for-each emit-lambda lambdas)
    (print "define i64 @prim_main() {")
    (for-each (fn (expr) (emit-expr (generate-var) empty-env expr)) preprocessed)
    (emit-ret (fixnum->string 0))
    (print "}")
))

; (defn debug-program (exprs)
;   (let ((preprocessed (map (fn (expr)
;                                (pipe expr syntax-desugar alpha-convert-expr closure-convert normalize-term))
;                            (append stdlib exprs))))
;     (print ">>> Global vars")
;     (for-each print global_vars)
;     (print ">>> Lambdas")
;     (for-each print lambdas)
;     (print ">>> Expressions")
;     (for-each print preprocessed)
; ))

(emit-program '(
; (debug-program '(
  (def x 1)

  (let ((x (fx+ x x))
        (x (fx+ x x))
        (x (fx+ x x)))
    (inspect x))

  (let* ((x (fx+ x x))
        (x (fx+ x x))
        (x (fx+ x x)))
    (inspect x))

  (inspect (read "(1 2 3)"))
  ; (def a 10)
  ; (defn fib (n)
  ;       (if (fx<=? n 1) n (fx+ (fib (fx- n 1))
  ;                              (fib (fx- n 2)))))
  ; (inspect (map fib (list 1 2 3 4 5 6)))
))
