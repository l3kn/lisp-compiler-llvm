(defn lambda? (expr)
      (tagged-list? expr 'fn))
(defn lambda-args (expr)
      (frst expr))
(defn lambda-body (expr)
      (make-sequence (rrst expr)))

(defn closure-convert-expr (expr)
  (closure-convert expr))

(def lambdas '())
(def global_vars '())

(defn closure-convert (expr)
  (cond
    ((lambda? expr)
     (let ((old-lambdas lambdas)
           (name (gensym))
           (arity (length (frst expr))))
       (set! lambdas (cons (list name expr) old-lambdas))
       (list 'closure name arity)))
    ((tagged-list? expr 'def)
     (let ((name (frst expr))
           (value (frrst expr))
           (old-global_vars global_vars))
       (set! global_vars (cons name global_vars))
       (list 'def name (closure-convert value))))
    ((let? expr)
     (let* ((bindings (let-bindings expr))
            (body (let-body expr))
            (new-bindings
              (map (fn (binding)
                     (list (let-binding-variable binding)
                           (closure-convert (let-binding-value binding))))
                   bindings)))
       (make-let new-bindings (closure-convert body))))
    ((list? expr)
     (map closure-convert expr))
    ((variable? expr) expr)
    ((atomic? expr) expr)
    (else
      (error "Can not closure convert expr: " expr))))
