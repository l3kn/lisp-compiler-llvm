(include "compatibility.scm")
(include "stdlib.scm")
(include "syntax.scm")
(include "helper.scm")
(include "llvm.scm")
(include "syntax/if.scm")
(include "syntax/begin.scm")
(include "syntax/let.scm")
(include "syntax/string.scm")
(include "preprocessing/syntax-desugar.scm")
(include "preprocessing/alpha-convert.scm")
(include "preprocessing/closure-convert.scm")

(def tag_mask #b111)
(def fixnum_tag #b000)

(def char_tag #b010)
(def constant_tag #b111)
(def true  #b111111)
(def false #b011111)
(def null  #b000111)

(defn immediate? (x)
  (or (fixnum? x) (boolean? x) (char? x) (null? x)))

(defn atomic? (x)
  (or (immediate? x) (symbol? x) (string? x))) 

(defn immediate-rep (x)
  (cond
    ((fixnum? x) 
     (fxshl x 3))
    ((char? x)
     (+ (fxshl (char->integer x) 3)
        char_tag))
    ((boolean? x)
     (if x true false))
    ((null? x) null)
    (else (error "Invalid expression: " x))))

(defn variable? (expr) (symbol? expr))

(defn emit-immediate (var expr)
      (~>> expr
           immediate-rep
           fixnum->string
           (emit-copy var)))

(defn emit-toplevel-expr (expr)
  (cond
    ((defprim? expr)
     (let* ((name (defprim-name expr))
            (args (defprim-args expr))
            (args-with-vars (map (fn (arg) (cons arg (generate-var))) args))
            (args-string
              (string-join2 (map (fn (a) (string-append "i64 " (rst a))) args-with-vars) ", ")))
       (print (string-append* (list "define i64 @" (escape name) "(" args-string ") {")))
       (emit-expr "%res" args-with-vars (defn-body expr))
       (emit-ret "%res")
       (print "}")))
     (else (error "Invalid toplevel expression: " expr))))

(defn emit-lambda (env expr)
  (let* ((name (fst expr))
         (lmbda (frst expr))
         (args (fn-params lmbda))
         (arity (length args))
         (body (fn-body lmbda))
         (args-with-vars (map (fn (arg) (cons arg (generate-var))) args))
         (args-string
           (string-join2 (map (fn (a) (string-append "i64 " (rst a))) args-with-vars) ", ")))
    (print (string-append* (list "define i64 @lambda_" (symbol->string name) "(" args-string ") {")))
    (emit-expr "%res" (append args-with-vars env) body)
    (emit-ret "%res")
    (print "}")))

(defn emit-global-var (var)
  (print (string-append* (list "@var_" (escape var) " = weak global i64 0"))))

(defn emit-expr (var env expr)
  (cond
    ((immediate? expr) (emit-immediate var expr))
    ((string? expr) (emit-string var expr))
    ((tagged-list? expr 'quote) (emit-symbol var (frst expr)))
    ((if? expr) (emit-if var env expr))
    ((begin? expr) (emit-begin var env expr))
    ((let? expr) (emit-let var env expr))
    ((tagged-list? expr 'make-closure)
     (let ((tmp1 (generate-var))
           (tmp2 (generate-var))
           (name (frst expr))
           (arity (frrst expr))
           (env_ (frrrst expr)))
       (print (string-append* (list "  " tmp1 " = ptrtoint i64 (" (arg-str (add1 arity)) ")* @lambda_" (symbol->string name) " to i64")))
       (emit-expr tmp2 env env_)
       (emit-call3 var "@internal_make-closure" tmp1 (fixnum->string (immediate-rep arity)) tmp2)
       ))
    ((def? expr)
     (let ((tmp (generate-var)))
       (emit-expr tmp env (def-value expr))
       (emit-store tmp (string-append "@var_" (escape (def-name expr))))))
    ; For now, `set!` is just converted to `def` in `closure-convert.scm`,
    ; the only difference is, that `def` adds an element to the list of global vars
    ; ((tagged-list? expr 'set!)
    ;  (let ((tmp (generate-var))
    ;        (name (frst expr))
    ;        (value (frrst expr)))
    ;    (emit-expr tmp env value)
    ;    (emit-store tmp (string-append "@var_" (escape name)))))
    ((list? expr)
     (let* ((name (fst expr))
            (args (rst expr))
            (args-with-vars (map (fn (a) (cons a (generate-var))) args)))
       (for-each (fn (av)
                     (emit-expr (rst av) env (fst av)))
                 args-with-vars)
       (let ((vars
               (map (fn (av) (string-append "i64 " (rst av)))
                    args-with-vars)))
       ; TODO: call emit-env with an initial env where all closures are bound to ther @var_...
       ; if a value is not in the env, assume it to be primitive
       (if (assoc name env)
           (begin
             (let ((tmp1 (generate-var))
                   (tmp2 (generate-var))
                   (tmp3 (generate-var))
                   (tmp4 (generate-var))
                   (arity (length args)))
               (emit-variable-ref tmp1 env name)
               (emit-call1 tmp2 "@internal_closure-function" tmp1)
               (emit-call1 tmp4 "@prim_closure-env" tmp1)
               (print (string-append* (list "  " tmp3 " = inttoptr i64 " tmp2 " to i64 (" (arg-str (add1 arity)) ")*")))  
               (if (> (length vars) 0)
                   (print (string-append* (list "  " var  " = call i64 " tmp3 "(i64 " tmp4 ", " (string-join2 vars ", ") ")")))
                   (print (string-append* (list "  " var  " = call i64 " tmp3 "(i64 " tmp4 ")"))))))
           (print (string-append* (list "  " var " = call i64 @" (escape name) "(" (string-join2 vars ", ") ")" )))))))
    ((variable? expr) (emit-variable-ref var env expr))
    (else
      (error "Unknown expression: " expr))))

(defn emit-variable-ref (var env expr)
  ; (print ">>> emit-var-ref " expr)
  (let ((res (assoc expr env)))
    (if res
      (if (eq? (string-ref (rst res) 0) #\@)
          (emit-load var (rst res))
          (emit-copy var (rst res)))
      (error "can't find " var " in env"))))

(defn emit-symbol (var expr)
  (let ((tmp (generate-var)))
    (emit-string tmp (symbol->string expr))
    (emit-call1 var "@prim_string-_greater_symbol" tmp)))

(defn debug-program (exprs)
  (let ((preprocessed (map (fn (expr)
                               (~> expr syntax-desugar alpha-convert-expr closure-convert))
                           (append stdlib exprs))))
    (print ">>> Global vars")
    (for-each print global-vars)
    (print ">>> Lambdas")
    (for-each print lambdas)
    (print ">>> Expressions")
    (for-each print preprocessed)
))
